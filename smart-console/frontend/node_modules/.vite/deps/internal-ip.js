import {
  __commonJS,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports, module) {
    "use strict";
    module.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/p-timeout/index.js"(exports, module) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally(
        // eslint-disable-next-line promise/prefer-await-to-then
        promise.then(resolve, reject),
        () => {
          clearTimeout(timer);
        }
      );
    });
    module.exports = pTimeout;
    module.exports.default = pTimeout;
    module.exports.TimeoutError = TimeoutError;
  }
});

// node_modules/p-event/index.js
var require_p_event = __commonJS({
  "node_modules/p-event/index.js"(exports, module) {
    "use strict";
    var pTimeout = require_p_timeout();
    var symbolAsyncIterator = Symbol.asyncIterator || "@@asyncIterator";
    var normalizeEmitter = (emitter) => {
      const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
      const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
      if (!addListener || !removeListener) {
        throw new TypeError("Emitter is not compatible");
      }
      return {
        addListener: addListener.bind(emitter),
        removeListener: removeListener.bind(emitter)
      };
    };
    var toArray = (value) => Array.isArray(value) ? value : [value];
    var multiple = (emitter, event, options) => {
      let cancel;
      const ret = new Promise((resolve, reject) => {
        options = {
          rejectionEvents: ["error"],
          multiArgs: false,
          resolveImmediately: false,
          ...options
        };
        if (!(options.count >= 0 && (options.count === Infinity || Number.isInteger(options.count)))) {
          throw new TypeError("The `count` option should be at least 0 or more");
        }
        const events = toArray(event);
        const items = [];
        const { addListener, removeListener } = normalizeEmitter(emitter);
        const onItem = (...args) => {
          const value = options.multiArgs ? args : args[0];
          if (options.filter && !options.filter(value)) {
            return;
          }
          items.push(value);
          if (options.count === items.length) {
            cancel();
            resolve(items);
          }
        };
        const rejectHandler = (error) => {
          cancel();
          reject(error);
        };
        cancel = () => {
          for (const event2 of events) {
            removeListener(event2, onItem);
          }
          for (const rejectionEvent of options.rejectionEvents) {
            removeListener(rejectionEvent, rejectHandler);
          }
        };
        for (const event2 of events) {
          addListener(event2, onItem);
        }
        for (const rejectionEvent of options.rejectionEvents) {
          addListener(rejectionEvent, rejectHandler);
        }
        if (options.resolveImmediately) {
          resolve(items);
        }
      });
      ret.cancel = cancel;
      if (typeof options.timeout === "number") {
        const timeout = pTimeout(ret, options.timeout);
        timeout.cancel = cancel;
        return timeout;
      }
      return ret;
    };
    var pEvent2 = (emitter, event, options) => {
      if (typeof options === "function") {
        options = { filter: options };
      }
      options = {
        ...options,
        count: 1,
        resolveImmediately: false
      };
      const arrayPromise = multiple(emitter, event, options);
      const promise = arrayPromise.then((array) => array[0]);
      promise.cancel = arrayPromise.cancel;
      return promise;
    };
    module.exports = pEvent2;
    module.exports.default = pEvent2;
    module.exports.multiple = multiple;
    module.exports.iterator = (emitter, event, options) => {
      if (typeof options === "function") {
        options = { filter: options };
      }
      const events = toArray(event);
      options = {
        rejectionEvents: ["error"],
        resolutionEvents: [],
        limit: Infinity,
        multiArgs: false,
        ...options
      };
      const { limit } = options;
      const isValidLimit = limit >= 0 && (limit === Infinity || Number.isInteger(limit));
      if (!isValidLimit) {
        throw new TypeError("The `limit` option should be a non-negative integer or Infinity");
      }
      if (limit === 0) {
        return {
          [Symbol.asyncIterator]() {
            return this;
          },
          async next() {
            return {
              done: true,
              value: void 0
            };
          }
        };
      }
      const { addListener, removeListener } = normalizeEmitter(emitter);
      let isDone = false;
      let error;
      let hasPendingError = false;
      const nextQueue = [];
      const valueQueue = [];
      let eventCount = 0;
      let isLimitReached = false;
      const valueHandler = (...args) => {
        eventCount++;
        isLimitReached = eventCount === limit;
        const value = options.multiArgs ? args : args[0];
        if (nextQueue.length > 0) {
          const { resolve } = nextQueue.shift();
          resolve({ done: false, value });
          if (isLimitReached) {
            cancel();
          }
          return;
        }
        valueQueue.push(value);
        if (isLimitReached) {
          cancel();
        }
      };
      const cancel = () => {
        isDone = true;
        for (const event2 of events) {
          removeListener(event2, valueHandler);
        }
        for (const rejectionEvent of options.rejectionEvents) {
          removeListener(rejectionEvent, rejectHandler);
        }
        for (const resolutionEvent of options.resolutionEvents) {
          removeListener(resolutionEvent, resolveHandler);
        }
        while (nextQueue.length > 0) {
          const { resolve } = nextQueue.shift();
          resolve({ done: true, value: void 0 });
        }
      };
      const rejectHandler = (...args) => {
        error = options.multiArgs ? args : args[0];
        if (nextQueue.length > 0) {
          const { reject } = nextQueue.shift();
          reject(error);
        } else {
          hasPendingError = true;
        }
        cancel();
      };
      const resolveHandler = (...args) => {
        const value = options.multiArgs ? args : args[0];
        if (options.filter && !options.filter(value)) {
          return;
        }
        if (nextQueue.length > 0) {
          const { resolve } = nextQueue.shift();
          resolve({ done: true, value });
        } else {
          valueQueue.push(value);
        }
        cancel();
      };
      for (const event2 of events) {
        addListener(event2, valueHandler);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        addListener(rejectionEvent, rejectHandler);
      }
      for (const resolutionEvent of options.resolutionEvents) {
        addListener(resolutionEvent, resolveHandler);
      }
      return {
        [symbolAsyncIterator]() {
          return this;
        },
        async next() {
          if (valueQueue.length > 0) {
            const value = valueQueue.shift();
            return {
              done: isDone && valueQueue.length === 0 && !isLimitReached,
              value
            };
          }
          if (hasPendingError) {
            hasPendingError = false;
            throw error;
          }
          if (isDone) {
            return {
              done: true,
              value: void 0
            };
          }
          return new Promise((resolve, reject) => nextQueue.push({ resolve, reject }));
        },
        async return(value) {
          cancel();
          return {
            done: isDone,
            value
          };
        }
      };
    };
    module.exports.TimeoutError = pTimeout.TimeoutError;
  }
});

// node_modules/ip-regex/index.js
var require_ip_regex = __commonJS({
  "node_modules/ip-regex/index.js"(exports, module) {
    "use strict";
    var word = "[a-fA-F\\d:]";
    var b = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
    var v4exact = new RegExp(`^${v4}$`);
    var v6exact = new RegExp(`^${v6}$`);
    var ip = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, "g");
    ip.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, "g");
    ip.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, "g");
    module.exports = ip;
  }
});

// node_modules/is-ip/index.js
var require_is_ip = __commonJS({
  "node_modules/is-ip/index.js"(exports, module) {
    "use strict";
    var ipRegex = require_ip_regex();
    var isIp2 = (string) => ipRegex({ exact: true }).test(string);
    isIp2.v4 = (string) => ipRegex.v4({ exact: true }).test(string);
    isIp2.v6 = (string) => ipRegex.v6({ exact: true }).test(string);
    isIp2.version = (string) => isIp2(string) ? isIp2.v4(string) ? 4 : 6 : void 0;
    module.exports = isIp2;
  }
});

// node_modules/internal-ip/browser.js
var import_p_event = __toESM(require_p_event());
var import_is_ip = __toESM(require_is_ip());
var getIp = async ({ isSecondTry = false } = {}) => {
  try {
    const peerConnection = new RTCPeerConnection({ iceServers: [] });
    peerConnection.createDataChannel("");
    peerConnection.createOffer(peerConnection.setLocalDescription.bind(peerConnection), () => {
    });
    const { candidate } = await (0, import_p_event.default)(peerConnection, "icecandidate", {
      timeout: 1e4
    });
    peerConnection.close();
    if (!(candidate && candidate.candidate)) {
      return;
    }
    const result = candidate.candidate.split(" ")[4];
    if (!result.endsWith(".local")) {
      return result;
    }
    if (isSecondTry) {
      return;
    }
    const inputDevices = await navigator.mediaDevices.enumerateDevices();
    const inputDeviceTypes = new Set(inputDevices.map(({ kind }) => kind));
    const constraints = {};
    if (inputDeviceTypes.has("audioinput")) {
      constraints.audio = true;
    } else if (inputDeviceTypes.has("videoinput")) {
      constraints.video = true;
    } else {
      return;
    }
    const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
    for (const track of mediaStream.getTracks()) {
      track.stop();
    }
    return await getIp({ isSecondTry: true });
  } catch {
  }
};
async function internalIpV6() {
  const result = await getIp();
  if (import_is_ip.default.v6(result)) {
    return result;
  }
}
async function internalIpV4() {
  const result = await getIp();
  if (import_is_ip.default.v4(result)) {
    return result;
  }
}
function internalIpV6Sync() {
  return void 0;
}
function internalIpV4Sync() {
  return void 0;
}
export {
  internalIpV4,
  internalIpV4Sync,
  internalIpV6,
  internalIpV6Sync
};
//# sourceMappingURL=internal-ip.js.map
